[TOC]

# Solidity

### 1. 컨트랙트

#### 1) 컨트랙트

- 이더리움 애플리케이션의 기본적인 구성 요소

- 모든 변수와 함수는 어느 한 컨트랙트에 속하게 마련

- 모든 프로젝트의 시작점

  ```js
  contract HelloWorld {
  	// HelloWorld 컨트랙트
  }
  ```

#### 2) Version Pragma

- 모든 솔리디티 소스 코드는 "version pragma"로 시작 

- 해당 코드가 이용해야 하는 솔리디티 버전 선언 

- 이후에 새로운 컴파일러 버전이 나와도 기존 코드가 깨지지 않도록 예방

  ```js
  pragma solidity ^0.4.19;
  
  contract HelloWorld {
  
  }
  ```



### 2. 상태 변수 & 정수

#### 1) 상태 변수

- 컨트랙트 저장소에 영구적으로 저장 - 이더리움 블록체인에 기록 

  ```js
  contract Example {
  	uint myUnsignedInteger = 100;
  }
  ```

#### 2) uint 

- 부호 없는 정수 -> 값이 음수가 아니어야 한다는 의미 

- int -> 부호 있는 정수



### 3. 구조체

- 여러 특성을 가진 좀 더 복잡한 자료형 생성 

  ```js
  struct Person {
  	uint age;
  	string name;
  }
  ```

  

### 4. 배열 

#### 1) 정적 배열 & 동적 배열

```js
// 2개의 원소를 담을 수 있는 고정 길이의 배열 
uint[2] fixedArray;

// 또 다른 고정 배열으로 5개의 스트링을 담을 수 있음
string[5] stringArray;

// 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있음
uint[] dynamicArray;
```



- 구조체의 배열을 생성할 수도 있음

  ```js
  // 위에 만들어둔 Person 구조체 사용 
  // 동적 배열, 원소 계속 추가 할 수 있음 
  Person[] people;
  ```

- 구조체의 동적 배열을 생성하면 마치 데이터베이스처럼 컨트랙트에 구조화된 데이터를 저장하는데 유용 

#### 2) Public 배열 

- public으로 배열 선언 

- solidity는 getter 메소드 자동으로 생성

  ```js
  // person 구조체의 public 배열 생성 
  Person[] public people;
  ```

- 다른 컨트랙트들이 이 배열을 읽을 수 있음 ( 쓰기는 X )

- 컨트랙트에 공개 데이터를 저장할 때 유용한 패턴



### 5. 함수 선언

```js
function eatHamburgers(string _name, uint _amount) {

}
```

- eatHamburgers : 함수 이름, string & uint 2개의 인자 전달 받음 
- 함수 인자명을 언더스코어(_)로 시작해서 전역 변수와 구별하는 것이 컨벤션

```js
// 이렇게 함수 호출
eatHamburgers("vitalik", 100);
```



### 6. 구조체와 배열 활용하기

```js
struct Person{
	uint age;
	string name;
}

Person[] public people;
```

- 여기서 새로운 Person 생성하고 people에 배열 추가해보자

```js
// 새로운 사람을 생성
Person satoshi = Person(172, 'Satoshi');

// 이 사람을 배열에 추가
people.push(satoshi);
```

```js
// 위의 두 코드를 조합하면
people.push(Person(172, "Satoshi"));

// array.push()는 무언가를 배열의 끝에 추가해서 모든 원소가 순서를 유지하도록 한다.
```

```js
uint[] numbers;
numbers.push(5);
numbers.push(10);
numbers.push(15);

// numbers 배열은 [5, 10, 15]
```



### 7. Private / Public 함수

- Solidity에서 함수는 기본적으로 public 선언 
- 즉, 누구나 나의 컨트랙트의 함수를 호출하고 코드를 실행할 수 있음 
- 그러면 내 컨트랙트를 공격당할 수 있으니까 기본적으로 private 쓰자!

```js
uint[] numbers;

function _addToArray(uint _number) private {
	numbers.push(_number);
}
```

- private는 함수명 다음에 써주고, private 함수명은 언더스코어(_)로 시작 



### 8. 함수 반환값 / 제어자

#### 1) 반환값

```js
string greeting = "What's up dog";

function sayHello() public returns (string) {
	return greeting;
}
```

- 함수 선언은 반환값 종류를 포함 

#### 2) 함수 제어자

- 위의 sayHello()는 solidity에서 상태를 변화시키지 않음, 즉, 어떤 값을 변경하거나 무언가를 쓰지 않음. 
- 이 경우에는 함수를 view로 선언 -> 함수가 데이터를 보기만 하고 변경하지 않음

```js
function sayHello() public view returns (string) {

}
```

- solidity는 pure 함수도 가지고 있음 -> 함수가 앱에서 어떤 데이터도 접근하지 않는 것을 의미 

```js
function _multiply(uint a, uint b) private pure returns (uint) {
	return a * b;
}
```

- 이 함수는 앱에서 읽는 것도 하지 않고, 다만 반환값이 함수에 전달된 인자값에 따라서 달라진다, 이 경우에 함수를 pure로 선언 



### 9. keccak256 / 형 변환

#### 1) keccak256

- 함수의 반환값이 (반)랜덤인 uint가 되기를 원하면 ?
- 이더리움은 SHA3의 한 버전인 keccak256를 내장 해시함수로 가지고 있다
- 해시 함수는 기본적으로 입력 스트링을 랜덤 256비트 16진수로 매핑
- 스트링에 약간의 변화라도 있으면 해시 값은 크게 달라진다

```js
//6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
keccak256("aaaab");

//b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
keccak256("aaaac");
```

#### 2) 형 변환

```js
uint8 a = 5;
uint b = 6;

// a * b가 uint8이 아닌 uint를 반환하기 때문에 에러 메시지가 난다
uint8 c = a * b;

// b를 uint8로 형 변환해서 코드가 제대로 작동해야 한다. 
uint8 c = a * uint8(b);
```



### 10. 이벤트

- 컨트랙트가 블록체인 상에서 앱의 사용자 단에서 무언가 액션이 발생했을 때 의사소통 하는 방법 
- 컨트랙트는 특정 이벤트가 일어나는지 보다가 이벤트가 발생하면 행동 취한다

```js
// 이벤트 선언 
event IntegersAdded(uint x, uint y, uint result);

function add(uint _x, uint _y) public {
	uint result = _x + _y;
	
	// 이벤트를 실행하여 앱에게 add 함수가 실행되었음을 알린다
	IntegersAdded(_x, _y, result);
	return result;
}
```

- 앱의 사용자 단은 해당 이벤트가 일어나는지 귀를 기울인다, 자바스크립트로 구현하면 

```js
YourContract.IntegersAdded(function(error, result) {
	// 결과와 관련된 행동 취함
})
```



### 11. Web3.js

- 컨트랙트와 상호작용하는 사용자 단의 자바스크립트 코드를 작성하자
- 이더리움은 Web3.js라고 하는 자바스크립트 라이브러리를 가지고 있다

```js
// 여기에 우리가 만든 컨트랙트에 접근하는 방법을 제시한다:
var abi = /* abi generated by the compiler */
var ZombieFactoryContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFactory = ZombieFactoryContract.at(contractAddress)
// `ZombieFactory`는 우리 컨트랙트의 public 함수와 이벤트에 접근할 수 있다.

// 일종의 이벤트 리스너가 텍스트 입력값을 취한다:
$("#ourButton").click(function(e) {
  var name = $("#nameInput").val()
  // 우리 컨트랙트의 `createRandomZombie`함수를 호출한다:
  ZombieFactory.createRandomZombie(name)
})

// `NewZombie` 이벤트가 발생하면 사용자 인터페이스를 업데이트한다
var event = ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  generateZombie(result.zombieId, result.name, result.dna)
})

// 좀비 DNA 값을 받아서 이미지를 업데이트한다
function generateZombie(id, name, dna) {
  let dnaStr = String(dna)
  // DNA 값이 16자리 수보다 작은 경우 앞 자리를 0으로 채운다
  while (dnaStr.length < 16)
    dnaStr = "0" + dnaStr

  let zombieDetails = {
    // 첫 2자리는 머리의 타입을 결정한다. 머리 타입에는 7가지가 있다. 그래서 모듈로(%) 7 연산을 하여
    // 0에서 6 중 하나의 값을 얻고 여기에 1을 더해서 1에서 7까지의 숫자를 만든다. 
    // 이를 기초로 "head1.png"에서 "head7.png" 중 하나의 이미지를 불러온다:
    headChoice: dnaStr.substring(0, 2) % 7 + 1,
    // 두번째 2자리는 눈 모양을 결정한다. 눈 모양에는 11가지가 있다:
    eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
    // 셔츠 타입에는 6가지가 있다:
    shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
    // 마지막 6자리는 색깔을 결정하며, 360도(degree)까지 지원하는 CSS의 "filter: hue-rotate"를 이용하여 아래와 같이 업데이트된다:
    skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
    eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
    clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
    zombieName: name,
    zombieDescription: "A Level 1 CryptoZombie",
  }
  return zombieDetails
}
```



### 12. 매핑과 주소

#### 1) 주소 

- 이더리움 블록체인은 은행 계좌와 같은 계정들로 이루어져 있다.
- 각 계정은 은행 계좌 번호와 같은 주소를 가지고 있다.
- 주소는 특정 계정을 가리키는 고유 식별자

#### 2) 매핑

- 솔리디티에서 구조화된 데이터를 저장하는 또 다른 방법

  ```js
  // 금융 앱용으로, 유저의 계좌 잔액을 보유하는 uint를 저장한다: 
  // key : address, value : unit
  mapping (address => uint) public accountBalance;
  
  // 혹은 userID로 유저 이름을 저장/검색하는 데 매핑을 쓸 수도 있다 
  // key : uint, value : string
  mapping (uint => string) userIdToName;
  ```

- 매핑은 키-값 (key-value) 저장소로, 데이터를 저장하고 검색하는데 이용됨



### 13. Msg.sender

- 모든 함수에서 이용 가능한 특정 전역 변수들 중 하나이다
- 현재 함수를 호출한 사람 (혹은 스마트 컨트랙트)의 주소를 가리키는 것

> 솔리디티에서 함수 실행은 항상 외부 호출자가 시작, 컨트랙트는 누군가가 컨트랙트의 함수를 호출할 때까지 블록체인 상에서 아무것도 안하고 있을 것이다. 그러니 항상 msg.sender가 있어야 한다

```js
mapping (address => uint) favoriteNumber;

function setMyNumber(uint _myNumber) public {
  // `msg.sender`에 대해 `_myNumber`가 저장되도록 `favoriteNumber` 매핑을 업데이트한다 `
  favoriteNumber[msg.sender] = _myNumber;
  // ^ 데이터를 저장하는 구문은 배열로 데이터를 저장할 떄와 동일하다 
}

function whatIsMyNumber() public view returns (uint) {
  // sender의 주소에 저장된 값을 불러온다 
  // sender가 `setMyNumber`을 아직 호출하지 않았다면 반환값은 `0`이 될 것이다
  return favoriteNumber[msg.sender];
}


```

- 위의 예시에서 누구나 seymyNumber를 호출하여 본인의 주소와 연결된 우리 컨트랙트 내에 uint 저장 
- msg.sender를 활용하면 이더리움 블록체인의 보안성을 이용할 수 있음 
- 누군가 다른 사람의 데이터를 변경하려면 해당 이더리움 주소와 관련된 개인키를 훔치는 것 밖에는 다른 방법이 없다는 것을 의미한다.

```js
// id에 대해 msg.sender가 저장되도록
zombieToOwner[id] = msg.sender;

// msg.sender를 고려하여 ownerZombieCount를 증가시키자
ownerZombieCount[msg.sender]++;
```



### 14. Require

- 특정 조건이 참이 아닐 때 함수가 에러 메시지를 발생하고 실행을 멈춘다.

  ```js
  function sayHiToVitalik(string _name) public returns (string) {
    // _name이 "Vitalik"인지 비교한다. 참이 아닐 경우 에러 메시지를 발생하고 함수를 벗어난다
    // (참고: 솔리디티는 고유의 스트링 비교 기능을 가지고 있지 않기 때문에 
    // 스트링의 keccak256 해시값을 비교하여 스트링 값이 같은지 판단한다)
    require(keccak256(_name) == keccak256("Vitalik"));
    // 참이면 함수 실행을 진행한다:
    return "Hi!";
  }
  ```

- _name이 "Vitalik" 일때만 함수 실행 될 것이다. 



### 15. 상속

- 엄청나게 긴 컨트랙트 하나를 만들기 보다 코드를 잘 정리해서 여러 컨트랙트에 코드 로직을 나누는 것이 합리적일 때가 있는데, 그때 사용하는게 상속 

  ```js
  contract Doge {
    function catchphrase() public returns (string) {
      return "So Wow CryptoDoge";
    }
  }
  
  // BabyDoge 컨트랙트는 Doge 컨트랙트 상속
  // 즉, BabtDoge 컨트랙트가 catchphrase() 함수와 anotherCatchphrase() 함수에 모두 접근 할 수 있음을 의미
  // Doge 컨트랙트에 정의되는 다른 어떤 public 함수가 정의되어도 접근 가능
  
  contract BabyDoge is Doge {
    function anotherCatchphrase() public returns (string) {
      return "Such Moon BabyDoge";
    }
  }
  ```



### 16. Import

- 코드가 꽤 길어지면, 여러 파일로 나누어서 정리하면 편하겠지

- 다수의 파일이 있고 어떤 파일을 다른 파일로 불러 오고 싶을 때, import

  ```js
  import "./someothercontract.sol";
  
  contract newContract is SomeOtherContract {
  
  }
  ```



### 17. Storage Vs Memory

- 변수를 저장할 수 있는 공간

- Storage => 블록체인 상에 영구적으로 저장되는 변수 
- Memory => 임시적으로 저장되는 변수, 컨트랙트 함수에 대한 외부 호출들이 일어나는 사이에 지워진다.
- 대부분은 솔리디티가 알아서 처리해준다
- 상태변수 (함수 외부에 선언된 변수)는 초기 설정상 storage로 선언되어 블록체인에 영구적으로 저장된다
- 함수 내에 선언된 변수는 memory로 자동 선언되어서 함수 호출이 종료되면 사라진다.

- 하지만 함수 내의 구조체와 배열을 처리할때는 키워드를 사용해야 한다

  ```js
  contract SandwichFactory {
    struct Sandwich {
      string name;
      string status;
    }
  
    Sandwich[] sandwiches;
  
    function eatSandwich(uint _index) public {
      // Sandwich mySandwich = sandwiches[_index];
  
      // ^ 꽤 간단해 보이나, 솔리디티는 여기서 
      // `storage`나 `memory`를 명시적으로 선언해야 한다는 경고 메시지를 발생한다. 
      // 그러므로 `storage` 키워드를 활용하여 다음과 같이 선언해야 한다:
      Sandwich storage mySandwich = sandwiches[_index];
      // ...이 경우, `mySandwich`는 저장된 `sandwiches[_index]`를 가리키는 포인터이다.
      // 그리고 
      mySandwich.status = "Eaten!";
      // ...이 코드는 블록체인 상에서 `sandwiches[_index]`을 영구적으로 변경한다. 
  
      // 단순히 복사를 하고자 한다면 `memory`를 이용하면 된다: 
      Sandwich memory anotherSandwich = sandwiches[_index + 1];
      // ...이 경우, `anotherSandwich`는 단순히 메모리에 데이터를 복사하는 것이 된다. 
      // 그리고 
      anotherSandwich.status = "Eaten!";
      // ...이 코드는 임시 변수인 `anotherSandwich`를 변경하는 것으로 
      // `sandwiches[_index + 1]`에는 아무런 영향을 끼치지 않는다. 그러나 다음과 같이 코드를 작성할 수 있다: 
      sandwiches[_index + 1] = anotherSandwich;
      // ...이는 임시 변경한 내용을 블록체인 저장소에 저장하고자 하는 경우이다.
    }
  }
  ```

  ```js
  // myZombie라는 Zombie형 변수 선언
  // storage 포인터가 될 것이며, zombies 배열의 _zombieId 인덱스가 가진 값에 부여
  
  Zombie storage myZombie = zombies[_zombieId];
  ```



### 18. 함수 접근 제어자

#### 1) Internal

- 함수가 정의된 컨트랙트를 상속하는 컨트랙트에서도 접근이 가능하다는 점 + pirvate

#### 2) External

- 함수가 컨트랙트 바깥에서만 호출될 수 있고 컨트랙트 내의 다른 함수에 의해 호출될 수 없다는 점 + public

```js
contract Sandwich {
  uint private sandwichesEaten = 0;

  function eat() internal {
    sandwichesEaten++;
  }
}

contract BLT is Sandwich {
  uint private baconSandwichesEaten = 0;

  function eatWithBacon() public returns (string) {
    baconSandwichesEaten++;
    // eat 함수가 internal로 선언되었기 때문에 여기서 호출이 가능하다 
    eat();
  }
}
```



### 19. 다른 컨트랙트와 상호작용하기 

- 블록체인 상에 있으면서 우리가 소유하지 않은 컨트랙트와 우리 컨트랙트가 상호작용을 하려면 인터페이스를 정의해야 한다

```js
contract LuckyNumber {
  mapping(address => uint) numbers;

  function setNum(uint _num) public {
    numbers[msg.sender] = _num;
  }

  function getNum(address _myAddress) public view returns (uint) {
    return numbers[_myAddress];
  }
}
```

```js
contract NumberInterface {
  function getNum(address _myAddress) public view returns (uint);
}
```

- LuckyNumber 컨트랙트의 getNum 함수를 이용하기 위해서는 LuckyNumber 컨트랙트의 인터페이스를 정의할 필요가 있다 
- 인터페이스를 정의하는 것이 컨트랙트를 정의하는 것과 유사 
- 다른 컨트랙트와 상호작용하고자 하는 함수만 선언할 뿐 다른 함수나 상태 변수를 언급하지 않음
- 함수 몸체를 정의하지 않고, 중괄호 쓰지 않고, 함수 선언을 세미콜론으로 간단하게 끝낸다
- 인터페이스는 컨트랙트 뼈대처럼 보인다, 컴파일러도 그렇게 인터페이스 인식 



### 20 . 인터페이스 활용하기

```js
contract NumberInterface {
  function getNum(address _myAddress) public view returns (uint);
}
```

```js
contract MyContract {
  address NumberInterfaceAddress = 0xab38...
  // ^ 이더리움상의 FavoriteNumber 컨트랙트 주소이다
  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress)
  // 이제 `numberContract`는 다른 컨트랙트를 가리키고 있다.

  function someFunction() public {
    // 이제 `numberContract`가 가리키고 있는 컨트랙트에서 `getNum` 함수를 호출할 수 있다:
    uint num = numberContract.getNum(msg.sender);
    // ...그리고 여기서 `num`으로 무언가를 할 수 있다
  }
}
```



### 21. 다수의 반환값 처리

```js
function multipleReturns() internal returns(uint a, uint b, uint c) {
  return (1, 2, 3);
}

function processMultipleReturns() external {
  uint a;
  uint b;
  uint c;
  // 다음과 같이 다수 값을 할당한다:
  (a, b, c) = multipleReturns();
}

// 혹은 단 하나의 값에만 관심이 있을 경우: 
function getLastReturnValue() external {
  uint c;
  // 다른 필드는 빈칸으로 놓기만 하면 된다: 
  (,,c) = multipleReturns();
}
```

```js
  function feedOnKitty(uint _zombieId, uint _kittyId) public{
        uint kittyDna;
        // 10개의 변수 반환 
        (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
        feedAndMultiply(_zombieId, kittyDna);
  }
```

```js
pragma solidity ^0.4.19;

import "./zombiefactory.sol";

contract KittyInterface {
  function getKitty(uint256 _id) external view returns (
    bool isGestating,
    bool isReady,
    uint256 cooldownIndex,
    uint256 nextActionAt,
    uint256 siringWithId,
    uint256 birthTime,
    uint256 matronId,
    uint256 sireId,
    uint256 generation,
    uint256 genes
  );
}

contract ZombieFeeding is ZombieFactory {

  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
  KittyInterface kittyContract = KittyInterface(ckAddress);

  function feedAndMultiply(uint _zombieId, uint _targetDna) public {
    require(msg.sender == zombieToOwner[_zombieId]);
    Zombie storage myZombie = zombies[_zombieId];
    _targetDna = _targetDna % dnaModulus;
    uint newDna = (myZombie.dna + _targetDna) / 2;
    _createZombie("NoName", newDna);
  }
////////유전자 값을 얻는게 목적임
  // 여기에 함수를 정의 
    function feedOnKitty(uint _zombieId, uint _kittyId) public {
        uint kittyDna;
         (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
        // 원하는 값인 kittyDna만 return 한 후 그 데이터로 밑에 먹이를줌 
         feedAndMultiply(_zombieId,kittyDna)
    }
}
```



### 22. 컨트랙트의 불변성 

- 이더리움에 컨트랙트를 배포하고 나면, 컨트랙트는 **변하지 않음**
- 컨트랙트로 배포한 최초의 코드는 항상, 블록체인에 영구적으로 존재
- 그 누구도 배포 이후에 함수를 수정하거나 예상치 못한 결과를 발생시키지 못함

```js
contract ZombieFeeding is ZombieFactory {

  KittyInterface kittyContract;

  function setKittyContractAddress(address _address) external {
    kittyContract = KittyInterface(_address);
  }
   ...
}
```



### 23. 소유 가능한 컨트랙트

#### - OpenZeppelin의 `Ownable` 컨트랙트

- OpenZeppelin은 자네의 DApp에서 사용할 수 있는, 안전하고 커뮤니티에서 검증받은 스마트 컨트랙트의 라이브러리

```js
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}
```

- 생성자 `function Ownable()`는 생성자. 컨트랙트와 동일한 이름을 가진,생략할 수 있는 특별한 함수 / 이 함수는 컨트랙트가 생성될 때 딱 한 번만 실행
- 함수 제어자(Function Modifier): `modifier onlyOwner()`. 제어자는 다른 함수들에 대한 접근을 제어하기 위해 사용되는 일종의 유사 함수. 보통 함수 실행 전의 요구사항 충족 여부를 확인하는 데에 사용. `onlyOwner`의 경우에는 접근을 제한해서 **오직** 컨트랙트의 **소유자**만 해당 함수를 실행할 수 있도록 하기 위해 사용 됨. 



### 24. onlyOwner 함수 제어자

- 함수 제어자는 함수처럼 보이지만, `function` 키워드 대신 `modifier` 키워드를 사용

```js
contract MyContract is Ownable {
  event LaughManiacally(string laughter);

  // 아래 `onlyOwner`의 사용 방법을 잘 보게:
  function likeABoss() external onlyOwner {
    LaughManiacally("Muahahahaha");
  }
}
```

> *참고: 이렇게 소유자가 컨트랙트에 특별한 권한을 갖도록 하는 것은 자주 필요하지만, 이게 악용될 수도 있다네. 예를 들어, 소유자가 다른 사람의 좀비를 뺏어올 수 있도록 하는 백도어 함수를 추가할 수도 있지!*

> *그러니 잘 기억하게. 이더리움에서 돌아가는 DApp이라고 해서 그것만으로 분산화되어 있다고 할 수는 없네. 반드시 전체 소스 코드를 읽어보고, 자네가 **잠재적으로 걱정할 만한, 소유자에 의한 특별한 제어가 불가능한 상태인지 확인**하게. 개발자로서는 자네가 잠재적인 버그를 수정하고 DApp을 안정적으로 유지하도록 하는 것과, 사용자들이 그들의 데이터를 믿고 저장할 수 있는 소유자가 없는 플랫폼을 만드는 것 사이에서 균형을 잘 잡는 것이 중요하네.*



### 25. 가스

- 사용자들이 내가 만든 DApp의 함수를 실행할 때마다 **_가스_**라고 불리는 화폐를 지불
- 사용자는 이더(ETH, 이더리움의 화폐)를 이용해서 가스를 사기 때문에, 내가 DApp 함수를 실행하려면 사용자들은 ETH를 소모

> 함수를 실행하는 것은 자네의 사용자들에게 실제 돈을 쓰게 하기 때문에, 이더리움에서 코드 최적화는 다른 프로그래밍 언어들에 비해 훨씬 더 중요하네. 만약 자네의 코드가 엉망이라면, 사용자들은 자네의 함수를 실행하기 위해 일종의 할증료를 더 내야 할 걸세. 그리고 수천 명의 사용자가 이런 불필요한 비용을 낸다면 할증료가 수십 억 원까지 쌓일 수 있지.



###  가스를 아끼기 위한 구조체 압축

- 기본적으로는 이런 하위 타입들을 쓰는 것은 아무런 이득이 없네. 왜냐하면 솔리디티에서는 `uint`의 크기에 상관없이 256비트의 저장 공간을 미리 잡아놓기 때문이지. 예를 들자면, `uint`(`uint256`) 대신에 `uint8`을 쓰는 것은 가스 소모를 줄이는 데에 아무 영향이 없음
- **하지만  `struct`의 안에서는 예외**

```JS
struct NormalStruct {
  uint a;
  uint b;
  uint c;
}

struct MiniMe {
  uint32 a;
  uint32 b;
  uint c;
}

// `mini`는 구조체 압축을 했기 때문에 `normal`보다 가스를 조금 사용할 것이네.
NormalStruct normal = NormalStruct(10, 20, 30);
MiniMe mini = MiniMe(10, 20, 30); 
```



- 동일한 데이터 타입은 하나로 묶어놓는 것이 좋네. 즉, 구조체에서 서로 옆에 있도록 선언하면 솔리디티에서 사용하는 저장 공간을 최소화
- 예를 들면, `uint c; uint32 a; uint32 b;`라는 필드로 구성된 구조체가 `uint32 a; uint c; uint32 b;` 필드로 구성된 구조체보다 가스를 덜 소모



### 26. 시간 단위

- 솔리디티는 시간을 다룰 수 있는 단위계를 기본적으로 제공
- 솔리디티는 또한 `seconds`, `minutes`, `hours`, `days`, `weeks`, `years` 같은 시간 단위 또한 포함

```JS
uint lastUpdated;

// `lastUpdated`를 `now`로 설정
function updateTimestamp() public {
  lastUpdated = now;
}
#쿨타임 주는거임
// 마지막으로 `updateTimestamp`가 호출된 뒤 5분이 지났으면 `true`를, 5분이 아직 지나지 않았으면 `false`를 반환
function fiveMinutesHavePassed() public view returns (bool) {
  return (now >= (lastUpdated + 5 minutes));
}
```

```JS
contract ZombieFactory is Ownable {

    event NewZombie(uint zombieId, string name, uint dna);

    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;
    uint cooldownTime = 1 days;

    struct Zombie {
      string name;
      uint dna;
      ### 구조체 수정해주고
      uint32 level;
      uint32 readyTime;
    }

    Zombie[] public zombies;

    mapping (uint => address) public zombieToOwner;
    mapping (address => uint) ownerZombieCount;

    function _createZombie(string _name, uint _dna) internal {
       ## 수정한 구조체 parameter 변경
        uint id = zombies.push(Zombie(_name, _dna, 1, uint32(now + cooldownTime))) - 1;
        zombieToOwner[id] = msg.sender;
        ownerZombieCount[msg.sender]++;
        NewZombie(id, _name, _dna);
    }
```



### 27. 좀비 대사용 대기 시간

#### - 구조체를 인수로 전달하기

```JS
function _doStuff(Zombie storage _zombie) internal {
  // _zombie로 할 수 있는 것들을 처리
  # Zombie라는 구조체를 _zombie로 전달
}
```



### 28. Public 함수 & 보안

```js
 function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) internal {
   ### internel과 require 등으로 중간 중간 다 조건을 걸어버림
    require(msg.sender == zombieToOwner[_zombieId]);
    Zombie storage myZombie = zombies[_zombieId];
    require(_isReady(myZombie));
    _targetDna = _targetDna % dnaModulus;
    uint newDna = (myZombie.dna + _targetDna) / 2;
    if (keccak256(_species) == keccak256("kitty")) {
      newDna = newDna - newDna % 100 + 99;
    }
    _createZombie("NoName", newDna);
    _triggerCooldown(myZombie);
  }
```



### 29. 함수 제어자의 또 다른 특징

#### - 인수를 가지는 함수 제어자

```js
// 사용자의 나이를 저장하기 위한 매핑
mapping (uint => uint) public age;

// 사용자가 특정 나이 이상인지 확인하는 제어자
modifier olderThan(uint _age, uint _userId) {
  require (age[_userId] >= _age);
  _;
}

// 차를 운전하기 위햐서는 16살 이상이어야 하네(적어도 미국에서는).
// `olderThan` 제어자를 인수와 함께 호출하려면 이렇게 하면 되네:
function driveCar(uint _userId) public olderThan(16, _userId) {
  // 필요한 함수 내용들
}
```

```js
ragma solidity ^0.4.19;

import "./zombiefeeding.sol";

contract ZombieHelper is ZombieFeeding {

  // 여기서 시작하게
  modifier aboveLevel(uint _level, uint _zombieId) {
    require(zombies[_zombieId].level >= _level);
    _; ## 나머지 함수를 실행한다는 의미로 넣어줘야함
    
  }

}
```



### 30. 'View' 함수를 사용해 가스 절약하기

- `view` 함수는 사용자에 의해 외부에서 호출되었을 때 가스를 전혀 소모하지 않음
- 이건 `view` 함수가 블록체인 상에서 실제로 어떤 것도 수정하지 않기 떄문임 - 데이터를 읽기만 함
- 그러니 함수에 `view` 표시를 하는 것은 `web3.js`에 이렇게 말하는 것과 같음. "이 함수는 실행할 때 자네 로컬 이더리움 노드에 질의만 날리면 되고, 블록체인에 어떤 트랜잭션도 만들지 않아"(트랜잭션은 모든 개별 노드에서 실행되어야 하고, 가스를 소모하네).

```js
  // 자네의 함수를 여기에 만들게
  function getZombiesByOwner(address _owner) external view returns(uint[]){
  }
```



* Storage는 비싸다

  - 비용을 최소화하기 위해서, 진짜 필요한 경우가 아니면 storage에 데이터를 쓰지 않는 것이 좋음



### 31. 메모리에 배열 선언하기

- Storage에 아무것도 쓰지 않고도 함수 안에 새로운 배열을 만들려면 배열에 `memory` 키워드를 쓰면 되네. 이 배열은 함수가 끝날 때까지만 존재할 것이고, 이는 `storage`의 배열을 직접 업데이트하는 것보다 가스 소모 측면에서 훨씬 저렴하네 - 외부에서 호출되는 `view` 함수라면 무료이지.
- 메모리에 배열을 선언하는 방법은 다음과 같네

```js
function getArray() external pure returns(uint[]) {
  // 메모리에 길이 3의 새로운 배열을 생성한다.
  uint[] memory values = new uint[](3);
  // 여기에 특정한 값들을 넣는다.
  values.push(1);
  values.push(2);
  values.push(3);
  // 해당 배열을 반환한다.
  return values;
}
```

```js
 function getZombiesByOwner(address _owner) external view returns(uint[]) {
    uint[] memory result = new uint[](ownerZombieCount[_owner]);
    ## 적당한 길이로 반환
    // 여기서 시작하게
    return result;
  }
```



### 32. For 반복문

- 함수 내에서 배열을 다룰 때, 그냥 storage에 해당 배열을 저장하는 것이 아니라 `for` 반복문을 사용해서 구성해야 할 때가 있을 것

```js
mapping (address => uint[]) public ownerToZombies

function getZombiesByOwner(address _owner) external view returns (uint[]) {
  return ownerToZombies[_owner];
}
```



### 이 방식의 문제

> 이러한 접근 방법은 구현의 간단함 때문에 매력적으로 보이지. 하지만 만약 나중에 한 좀비를 원래 소유자에서 다른 사람에게 전달하는 함수를 구현하게 된다면 어떤 일이 일어날지 생각해보세(이후의 레슨에서 우린 분명 이 기능을 원하게 될 것일세).

1. 전달할 좀비를 새로운 소유자의 `ownerToZombies` 배열에 넣는다.
2. 기존 소유자의 `ownerToZombies` 배열에서 해당 좀비를 지운다.
3. 좀비가 지워진 구멍을 메우기 위해 기존 소유자의 배열에서 모든 좀비를 한 칸씩 움직인다.
4. 배열의 길이를 1 줄인다.

> 3번째 단계는 극단적으로 가스 소모가 많을 것이네. 왜냐하면 위치를 바꾼 모든 좀비에 대해 쓰기 연산을 해야 하기 때문이지. 소유자가 20마리의 좀비를 가지고 있고 첫 번째 좀비를 거래한다면, 배열의 순서를 유지하기 위해 우린 19번의 쓰기를 해야 할 것이네.



```js
function getEvens() pure external returns(uint[]) {
  uint[] memory evens = new uint[](5);
  // 새로운 배열의 인덱스를 추적하는 변수
  uint counter = 0;
  // for 반복문에서 1부터 10까지 반복함
  for (uint i = 1; i <= 10; i++) {
    // `i`가 짝수라면...
    if (i % 2 == 0) {
      // 배열에 i를 추가함
      evens[counter] = i;
      // `evens`의 다음 빈 인덱스 값으로 counter를 증가시킴
      counter++;
    }
  }
  return evens;
}
```

